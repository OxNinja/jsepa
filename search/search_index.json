{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home JavaScript Enhancement Proposals Agreement, JSEPA This projects aims to centralize the globally well-used coding conventions, and thus make this knowledge accessible to anyone. Tip This project was mainly inspired by the famous Python Enhancement Proposals, PEP . Introduction The first use of the JSEPA is to provide well-defined, clear and functionnal coding style for the JavaScript scripting language. With time and patience, good practices and specifically JavaScript-aimed proposals will emerge by the community. Index JSEPA-1 : JSEPA guidelines and definition JSEPA-2 : JavaScript coding style and guidelines Sources The JSEPA project is based on the actual online guidelines and tips about JavaScript, such as: https://developer.mozilla.org/en-US/docs/MDN/Guidelines/Code_guidelines/JavaScript https://github.com/airbnb/javascript","title":"Home"},{"location":"#home","text":"","title":"Home"},{"location":"#javascript-enhancement-proposals-agreement-jsepa","text":"This projects aims to centralize the globally well-used coding conventions, and thus make this knowledge accessible to anyone. Tip This project was mainly inspired by the famous Python Enhancement Proposals, PEP .","title":"JavaScript Enhancement Proposals Agreement, JSEPA"},{"location":"#introduction","text":"The first use of the JSEPA is to provide well-defined, clear and functionnal coding style for the JavaScript scripting language. With time and patience, good practices and specifically JavaScript-aimed proposals will emerge by the community.","title":"Introduction"},{"location":"#index","text":"JSEPA-1 : JSEPA guidelines and definition JSEPA-2 : JavaScript coding style and guidelines","title":"Index"},{"location":"#sources","text":"The JSEPA project is based on the actual online guidelines and tips about JavaScript, such as: https://developer.mozilla.org/en-US/docs/MDN/Guidelines/Code_guidelines/JavaScript https://github.com/airbnb/javascript","title":"Sources"},{"location":"contribute/","text":"Contributing Contributing to this project is highly appreciated. One can do so by creating an issue or a pull request on the Github repository. Contributors Author: 0xNinja Contributors:","title":"Contributing"},{"location":"contribute/#contributing","text":"Contributing to this project is highly appreciated. One can do so by creating an issue or a pull request on the Github repository.","title":"Contributing"},{"location":"contribute/#contributors","text":"Author: 0xNinja Contributors:","title":"Contributors"},{"location":"jsepas/","text":"List of all JSEPAs The validated JSEPAs are listed here.","title":"List of all JSEPAs"},{"location":"jsepas/#list-of-all-jsepas","text":"The validated JSEPAs are listed here.","title":"List of all JSEPAs"},{"location":"jsepas/jsepa-1/","text":"JSEPAS-1: JSEPA guidelines and definition What is JSEPA Pronounced /d\u0292e\u026a\u025bsipa/ for JS-EPA, or /\u0292s\u025bp\u00e6/ , as \"j'sais pas\" in French. Types of JSEPA Standards track : describes a new feature or implementation Informationnal : describes a JavaScript issue, or provides general guidelines or information to the JavaScript community. JSEPA workflow Submitting a JSEPA","title":"JSEPAS-1: JSEPA guidelines and definition"},{"location":"jsepas/jsepa-1/#jsepas-1-jsepa-guidelines-and-definition","text":"","title":"JSEPAS-1: JSEPA guidelines and definition"},{"location":"jsepas/jsepa-1/#what-is-jsepa","text":"Pronounced /d\u0292e\u026a\u025bsipa/ for JS-EPA, or /\u0292s\u025bp\u00e6/ , as \"j'sais pas\" in French.","title":"What is JSEPA"},{"location":"jsepas/jsepa-1/#types-of-jsepa","text":"Standards track : describes a new feature or implementation Informationnal : describes a JavaScript issue, or provides general guidelines or information to the JavaScript community.","title":"Types of JSEPA"},{"location":"jsepas/jsepa-1/#jsepa-workflow","text":"","title":"JSEPA workflow"},{"location":"jsepas/jsepa-1/#submitting-a-jsepa","text":"","title":"Submitting a JSEPA"},{"location":"jsepas/jsepa-2/","text":"JSEPA-2: JavaScript coding style and guidelines Introduction This JSEPA aims to provide some general and simple guidelines for anyone. Some more specific recommandations are also yielded here. General guidelines The guidelines provided are here to homogenize the codebase of any application: every files, every lines, have to look like they were writen by one and only one person, regardless of the number of collaborators. Tabs/space length According to the knowledge we have at the time writing this text, there is no standard size for indentation. But one agreement emerged from all the sources we read: all the code must have and keep the same tab/space size. Expanded syntax It is better to use an expanded syntax in JavaScript: \u2705 Expanded \u274c Not expanded function myFunc () { console . log ( \"My function here\" ); return 3 ; } function myFunc () { console . log ( \"My function here\" ); return 3 ; } As both syntaxes have the same result, it is preffered to use the expanded one, for readability and understanding the code. Comments A one-line comment in JavaScript is represented by a double slash // followed by a single space and the content of the comment. For a better understanding and reading, a one-line commment must be on one separated line of the code it is commenting: A multi-line comment is represented by a block containing the content of the comment and surrounded by /* (comment opener) and */ (comment closer). For better reading, a multi-line comment must have its comment lines starting with an asterisk ( * ), which must also be aligned with the above (previous) one. The multi-line comment must and with the closing tag ( */ ) in a separated line of the last line of comment, and its asterisk must be aligned with the previous one as well. \u2705 // \u274c // \u2705 /* \u274c /* // This variabe does x... const myVar = 42 ; // My comment console . log ( \"Hello\" ); // And an other one document . location . href = \"https://github.com\" ; const myVar = 42 ; // This variabe does x... console . log ( \"Hello\" ); // My comment document . location . href = \"https://github.com\" ; // And an other one /* This variable does: * x, * y, * z... */ const myVar = 42 ; /* This variable does: x, * y, z... */ const myVar = 42 ; Coding syntax Here are some examples of coding style to use for different situations. Those examples are here to improve the consistency fo the coding syntax, help for readability and understanding of the code. Semicolons Control statements Spacing By design the code should complies with the \"use strict\"; syntax: // \u2705 const myValue = 9 ; for ( let i = 0 ; i < myValue ; i ++ ) { let result = myValue + i ; console . log ( result ); } // \u274c const myValue = 9 for ( let i = 0 ; i < myValue ; i ++ ) { let result = myValue + i console . log ( result ) } The specification for control statements goes like so: No space between the keyword ( if , while ...) and the opening parenthesis 1 space between the closing parenthesis and the opening curly bracket // \u2705 if ( condition ) { code (); } // \u274c if ( condition ){ code (); } Spacing the code with empty lines is mandatory for good-looking and readable code. Here are some simple rules for spacing: 1 empty line between two methods of a class 2 empty lines around a function 2 empty lines around a class 1 empty line after imports/includes (which should be the first lines of a script) Info The spacing specified here is very inspired by the PEP-8 convention coding style for Python. // \u2705 Good line spacing class MyClass { constructor () { doThings (); } myMethod () { doThings (); } } function doThings () { return 0 ; } // \u274c Bad line spacing class MyClass { constructor () { doThings (); } myMethod () { doThings (); } } function doThings () { return 0 ; } Strings One must prefer to use template litterals instead of string concatenation for code readability: const value = 42 ; const name = \"Bob\" ; // \u2705 Template litteral console . log ( `The value is ${ value } and the name is ${ name } .` ); // \u274c String concatenation console . log ( \"The value is \" + value + \" and the name is \" + name + \".\" ); Variables Naming The naming convention in JavaScript for variables is lowerCamelCase, and using a self-explaining name is a must-do (but don't overdo it). Using underscore is also not recommanded: // \u2705 Valid const myAnimal = \"dog\" ; // \u274c Invalid const a = \"cat\" ; // \u274c Invalid const MY_ANIMAL = \"bird\" ; // \u274c Invalid const theNameOfMyFavouriteAnimalInTheHouseIsTheFollowing = \"Oliver\" ; // \u274c Invalid const my_animal = \"mouse\" ; // \u274c Invalid const _myAnimal = \"horse\" ; // \u274c Invalid const myAnimal__ = \"tortoise\" ; It is also preffered to name the variabes according to its purpose: Booleans Use one of the prefixes is , are or even has to explicit the boolean variable: let isValid = true ; let areCarsWorking = false ; let hasBeenHere = true ; Declaring To declare variables, the intended way is to use either the const or let keyword. Each one have its own usecase: const : declaring a constant. It's value is not meant to change. Scope: block. let : declaring a variable. Scope: block. // \u2705 Valid const myAnimal = \"dog\" ; // \u2705 Valid let myAnimal = \"hamster\" ; // \u274c Invalid var myAnimal = \"cat\" ; Why the var keyword is invalid? Well, it is not invalid, but the main purpose of not using it is its scope. var is function-scopped, while both const and let are block-scopped. In addition, var is writeable, so there is no warranty for constants defined with var , as per definition, are not read-only. Functions Declaring Never declare a function with the new Function() constructor as it uses plain text code evaluation wich may lead to security vulnerabilities: // \u274c Don't do that let a = document . getElementById ( \"a-user-input\" ). value ; let b = document . getElementById ( \"b-user-input\" ). value ; let operation = document . getElementById ( \"operator-user-input\" ). value ; const calculate = new Function ( \"a\" , \"b\" , `return a ${ operator } b` ); Security advisory Here the calculate() function will compute the result of the provded operation with 2 numbers. An attacker could input as the operator +(malicious_code)// instead of just + or - to achieve execution of some malicious code. For better security by design, one should code the above code like so: // This is an example of code to avoid using code evaluation, // under no circumstances this shoud be used as a vulnerability-proof code let a = document . getElementById ( \"a-user-input\" ). value ; let b = document . getElementById ( \"b-user-input\" ). value ; let operation = document . getElementById ( \"operator-user-input\" ). value ; const calculate = ( a = 0 , b = 0 , operation = '+' ) => { // Check if a and b are numbers ommited for size of code switch ( operation ) { case \"+\" : return a + b ; case \"-\" : return a - b ; default : console . log ( \"Operation not supported yet.\" ); return - 1 ; } } Async functions To call an async function inside a non-async function one should use the instant call expression: ( async function myAsyncFunc () { await doThis (); console . log ( \"Done\" ); })(); // Or using an anonymous arrow function ( async () => { await doThis (); console . log ( \"Done\" ); })(); Parameters Multiline signature If a function needs a mutiline signature, all the arguments must be on one separated line of each other: // \u2705 Valid function myFunc ( one , two , three , four ) { doThings (); } // \u274c Invalid function myFunc ( one , two , three , four ) { doThings (); } // \u274c Invalid function myFunc ( one , two , three , four ) { doThings (); } Default parameters It is preffered to use the default parameter syntax instead of mutating: Note The order of default parameter is important too: the parameters with default values must be at the end of the list of all parameters. // \u2705 Valid function myFunc ( value1 , value2 = 3 ) { return value1 + value2 ; } // \u274c Invalid function myFunc ( value1 , value2 ) { value1 = value1 || 0 ; if ( value2 === void 0 ) { value2 = 3 ; } return value1 + value2 ; } Parameters reassignment Never reassign a parameter inside a function, this can lead to unwanted behavious when dealing with the arguments object, and cause optimization issues, use variables instead: // \u2705 Preffered function myFunc ( a ) { let myNewA = a + \"My value\" ; return myNewA ; } // \u274c Don't do that function myFunc ( a ) { a += \"My value\" ; return a ; } Arrow functions Arrow functions can be used -- and this is the preffered way -- to keep the this keyword: Tip This trick is in fact the recommanded way to keep the this keyword in a class' method. function myFunction () { this . value = 0 ; this . otherFunction = ( x ) => { this . value = x ; } } Classes Naming Unlike variables, classes uses the PascalCase convention: // \u2705 Valid class MyClass { constructor () { this . value = 1 ; } } // \u274c Invalid class myClass { constructor () { this . value = 1 ; } } Methods Methods chaining Methods can return this to encourage methods chaining: class Dog { constructor ( name ) { this . name = name ; } play () { console . log ( \"Waf!\" ); return this ; } eat () { console . log ( \"Nom nom nom\" ); return this ; } sleep () { console . log ( \"Zzzzzz\" ); return this ; } } const myDog = new Dog (); myDog . play () . eat () . sleep (); Static methods If a method does not use this , it should be marked as a static method: class MyClass () { static method () { return 1 ; } } Operations Strict comparisons To compare values of two variables, one must prefer to use strict comparison operations: const name1 = \"John\" ; const name2 = \"James\" ; // \u2705 Valid if ( name1 === name2 ) { return true ; } else if ( name1 !== name2 ) { return false ; } // \u274c Invalid if ( name1 == name2 ) { return true ; } else if ( name1 != name2 ) { return false ; } Boolean tests For boolean tests, it it preffered to use the shortcodes of expressions instead of explicit testing the values: // \u2705 Valid if ( myVar ) { doThings (); } else { doOtherThing (); } // \u274c Invalid if ( myVar === true ) { doThings (); } else { doOtherThing (); } Simplify if possible For commom operations, it is sometimes possible to simplify the code: \u274c Not optimized \u2705 Optimized function myTest ( myVar ) { if ( myVar === true ) { return true ; } else { return false ; } } function myTest ( myVar ) { return myVar ; // (1) } At this point, this function is not realistic, but you get the idea for optimization Code examples The following projects are not affiliated with the JSEPA, but are good examples to follow: Feel free to push projects here.","title":"JSEPA-2: JavaScript coding style and guidelines"},{"location":"jsepas/jsepa-2/#jsepa-2-javascript-coding-style-and-guidelines","text":"","title":"JSEPA-2: JavaScript coding style and guidelines"},{"location":"jsepas/jsepa-2/#introduction","text":"This JSEPA aims to provide some general and simple guidelines for anyone. Some more specific recommandations are also yielded here.","title":"Introduction"},{"location":"jsepas/jsepa-2/#general-guidelines","text":"The guidelines provided are here to homogenize the codebase of any application: every files, every lines, have to look like they were writen by one and only one person, regardless of the number of collaborators.","title":"General guidelines"},{"location":"jsepas/jsepa-2/#tabsspace-length","text":"According to the knowledge we have at the time writing this text, there is no standard size for indentation. But one agreement emerged from all the sources we read: all the code must have and keep the same tab/space size.","title":"Tabs/space length"},{"location":"jsepas/jsepa-2/#expanded-syntax","text":"It is better to use an expanded syntax in JavaScript: \u2705 Expanded \u274c Not expanded function myFunc () { console . log ( \"My function here\" ); return 3 ; } function myFunc () { console . log ( \"My function here\" ); return 3 ; } As both syntaxes have the same result, it is preffered to use the expanded one, for readability and understanding the code.","title":"Expanded syntax"},{"location":"jsepas/jsepa-2/#comments","text":"A one-line comment in JavaScript is represented by a double slash // followed by a single space and the content of the comment. For a better understanding and reading, a one-line commment must be on one separated line of the code it is commenting: A multi-line comment is represented by a block containing the content of the comment and surrounded by /* (comment opener) and */ (comment closer). For better reading, a multi-line comment must have its comment lines starting with an asterisk ( * ), which must also be aligned with the above (previous) one. The multi-line comment must and with the closing tag ( */ ) in a separated line of the last line of comment, and its asterisk must be aligned with the previous one as well. \u2705 // \u274c // \u2705 /* \u274c /* // This variabe does x... const myVar = 42 ; // My comment console . log ( \"Hello\" ); // And an other one document . location . href = \"https://github.com\" ; const myVar = 42 ; // This variabe does x... console . log ( \"Hello\" ); // My comment document . location . href = \"https://github.com\" ; // And an other one /* This variable does: * x, * y, * z... */ const myVar = 42 ; /* This variable does: x, * y, z... */ const myVar = 42 ;","title":"Comments"},{"location":"jsepas/jsepa-2/#coding-syntax","text":"Here are some examples of coding style to use for different situations. Those examples are here to improve the consistency fo the coding syntax, help for readability and understanding of the code. Semicolons Control statements Spacing By design the code should complies with the \"use strict\"; syntax: // \u2705 const myValue = 9 ; for ( let i = 0 ; i < myValue ; i ++ ) { let result = myValue + i ; console . log ( result ); } // \u274c const myValue = 9 for ( let i = 0 ; i < myValue ; i ++ ) { let result = myValue + i console . log ( result ) } The specification for control statements goes like so: No space between the keyword ( if , while ...) and the opening parenthesis 1 space between the closing parenthesis and the opening curly bracket // \u2705 if ( condition ) { code (); } // \u274c if ( condition ){ code (); } Spacing the code with empty lines is mandatory for good-looking and readable code. Here are some simple rules for spacing: 1 empty line between two methods of a class 2 empty lines around a function 2 empty lines around a class 1 empty line after imports/includes (which should be the first lines of a script) Info The spacing specified here is very inspired by the PEP-8 convention coding style for Python. // \u2705 Good line spacing class MyClass { constructor () { doThings (); } myMethod () { doThings (); } } function doThings () { return 0 ; } // \u274c Bad line spacing class MyClass { constructor () { doThings (); } myMethod () { doThings (); } } function doThings () { return 0 ; }","title":"Coding syntax"},{"location":"jsepas/jsepa-2/#strings","text":"One must prefer to use template litterals instead of string concatenation for code readability: const value = 42 ; const name = \"Bob\" ; // \u2705 Template litteral console . log ( `The value is ${ value } and the name is ${ name } .` ); // \u274c String concatenation console . log ( \"The value is \" + value + \" and the name is \" + name + \".\" );","title":"Strings"},{"location":"jsepas/jsepa-2/#variables","text":"","title":"Variables"},{"location":"jsepas/jsepa-2/#naming","text":"The naming convention in JavaScript for variables is lowerCamelCase, and using a self-explaining name is a must-do (but don't overdo it). Using underscore is also not recommanded: // \u2705 Valid const myAnimal = \"dog\" ; // \u274c Invalid const a = \"cat\" ; // \u274c Invalid const MY_ANIMAL = \"bird\" ; // \u274c Invalid const theNameOfMyFavouriteAnimalInTheHouseIsTheFollowing = \"Oliver\" ; // \u274c Invalid const my_animal = \"mouse\" ; // \u274c Invalid const _myAnimal = \"horse\" ; // \u274c Invalid const myAnimal__ = \"tortoise\" ; It is also preffered to name the variabes according to its purpose: Booleans Use one of the prefixes is , are or even has to explicit the boolean variable: let isValid = true ; let areCarsWorking = false ; let hasBeenHere = true ;","title":"Naming"},{"location":"jsepas/jsepa-2/#declaring","text":"To declare variables, the intended way is to use either the const or let keyword. Each one have its own usecase: const : declaring a constant. It's value is not meant to change. Scope: block. let : declaring a variable. Scope: block. // \u2705 Valid const myAnimal = \"dog\" ; // \u2705 Valid let myAnimal = \"hamster\" ; // \u274c Invalid var myAnimal = \"cat\" ; Why the var keyword is invalid? Well, it is not invalid, but the main purpose of not using it is its scope. var is function-scopped, while both const and let are block-scopped. In addition, var is writeable, so there is no warranty for constants defined with var , as per definition, are not read-only.","title":"Declaring"},{"location":"jsepas/jsepa-2/#functions","text":"","title":"Functions"},{"location":"jsepas/jsepa-2/#declaring_1","text":"Never declare a function with the new Function() constructor as it uses plain text code evaluation wich may lead to security vulnerabilities: // \u274c Don't do that let a = document . getElementById ( \"a-user-input\" ). value ; let b = document . getElementById ( \"b-user-input\" ). value ; let operation = document . getElementById ( \"operator-user-input\" ). value ; const calculate = new Function ( \"a\" , \"b\" , `return a ${ operator } b` ); Security advisory Here the calculate() function will compute the result of the provded operation with 2 numbers. An attacker could input as the operator +(malicious_code)// instead of just + or - to achieve execution of some malicious code. For better security by design, one should code the above code like so: // This is an example of code to avoid using code evaluation, // under no circumstances this shoud be used as a vulnerability-proof code let a = document . getElementById ( \"a-user-input\" ). value ; let b = document . getElementById ( \"b-user-input\" ). value ; let operation = document . getElementById ( \"operator-user-input\" ). value ; const calculate = ( a = 0 , b = 0 , operation = '+' ) => { // Check if a and b are numbers ommited for size of code switch ( operation ) { case \"+\" : return a + b ; case \"-\" : return a - b ; default : console . log ( \"Operation not supported yet.\" ); return - 1 ; } }","title":"Declaring"},{"location":"jsepas/jsepa-2/#async-functions","text":"To call an async function inside a non-async function one should use the instant call expression: ( async function myAsyncFunc () { await doThis (); console . log ( \"Done\" ); })(); // Or using an anonymous arrow function ( async () => { await doThis (); console . log ( \"Done\" ); })();","title":"Async functions"},{"location":"jsepas/jsepa-2/#parameters","text":"","title":"Parameters"},{"location":"jsepas/jsepa-2/#multiline-signature","text":"If a function needs a mutiline signature, all the arguments must be on one separated line of each other: // \u2705 Valid function myFunc ( one , two , three , four ) { doThings (); } // \u274c Invalid function myFunc ( one , two , three , four ) { doThings (); } // \u274c Invalid function myFunc ( one , two , three , four ) { doThings (); }","title":"Multiline signature"},{"location":"jsepas/jsepa-2/#default-parameters","text":"It is preffered to use the default parameter syntax instead of mutating: Note The order of default parameter is important too: the parameters with default values must be at the end of the list of all parameters. // \u2705 Valid function myFunc ( value1 , value2 = 3 ) { return value1 + value2 ; } // \u274c Invalid function myFunc ( value1 , value2 ) { value1 = value1 || 0 ; if ( value2 === void 0 ) { value2 = 3 ; } return value1 + value2 ; }","title":"Default parameters"},{"location":"jsepas/jsepa-2/#parameters-reassignment","text":"Never reassign a parameter inside a function, this can lead to unwanted behavious when dealing with the arguments object, and cause optimization issues, use variables instead: // \u2705 Preffered function myFunc ( a ) { let myNewA = a + \"My value\" ; return myNewA ; } // \u274c Don't do that function myFunc ( a ) { a += \"My value\" ; return a ; }","title":"Parameters reassignment"},{"location":"jsepas/jsepa-2/#arrow-functions","text":"Arrow functions can be used -- and this is the preffered way -- to keep the this keyword: Tip This trick is in fact the recommanded way to keep the this keyword in a class' method. function myFunction () { this . value = 0 ; this . otherFunction = ( x ) => { this . value = x ; } }","title":"Arrow functions"},{"location":"jsepas/jsepa-2/#classes","text":"","title":"Classes"},{"location":"jsepas/jsepa-2/#naming_1","text":"Unlike variables, classes uses the PascalCase convention: // \u2705 Valid class MyClass { constructor () { this . value = 1 ; } } // \u274c Invalid class myClass { constructor () { this . value = 1 ; } }","title":"Naming"},{"location":"jsepas/jsepa-2/#methods","text":"","title":"Methods"},{"location":"jsepas/jsepa-2/#methods-chaining","text":"Methods can return this to encourage methods chaining: class Dog { constructor ( name ) { this . name = name ; } play () { console . log ( \"Waf!\" ); return this ; } eat () { console . log ( \"Nom nom nom\" ); return this ; } sleep () { console . log ( \"Zzzzzz\" ); return this ; } } const myDog = new Dog (); myDog . play () . eat () . sleep ();","title":"Methods chaining"},{"location":"jsepas/jsepa-2/#static-methods","text":"If a method does not use this , it should be marked as a static method: class MyClass () { static method () { return 1 ; } }","title":"Static methods"},{"location":"jsepas/jsepa-2/#operations","text":"","title":"Operations"},{"location":"jsepas/jsepa-2/#strict-comparisons","text":"To compare values of two variables, one must prefer to use strict comparison operations: const name1 = \"John\" ; const name2 = \"James\" ; // \u2705 Valid if ( name1 === name2 ) { return true ; } else if ( name1 !== name2 ) { return false ; } // \u274c Invalid if ( name1 == name2 ) { return true ; } else if ( name1 != name2 ) { return false ; }","title":"Strict comparisons"},{"location":"jsepas/jsepa-2/#boolean-tests","text":"For boolean tests, it it preffered to use the shortcodes of expressions instead of explicit testing the values: // \u2705 Valid if ( myVar ) { doThings (); } else { doOtherThing (); } // \u274c Invalid if ( myVar === true ) { doThings (); } else { doOtherThing (); }","title":"Boolean tests"},{"location":"jsepas/jsepa-2/#simplify-if-possible","text":"For commom operations, it is sometimes possible to simplify the code: \u274c Not optimized \u2705 Optimized function myTest ( myVar ) { if ( myVar === true ) { return true ; } else { return false ; } } function myTest ( myVar ) { return myVar ; // (1) } At this point, this function is not realistic, but you get the idea for optimization","title":"Simplify if possible"},{"location":"jsepas/jsepa-2/#code-examples","text":"The following projects are not affiliated with the JSEPA, but are good examples to follow: Feel free to push projects here.","title":"Code examples"}]}